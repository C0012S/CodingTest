/*
PCCP 모의고사 2회. #121690 - [PCCP 모의고사 2] 4번, 보물 지도

    문제 설명
        진수는 보물이 묻힌 장소와 함정이 표시된 보물 지도를 이용해 보물을 찾으려 합니다. 보물지도는 가로 길이가 n, 세로 길이가 m인 직사각형 모양입니다.
        맨 왼쪽 아래 칸의 좌표를 (1, 1)으로, 맨 오른쪽 위 칸의 좌표를 (n, m)으로 나타냈을 때, 보물은 (n, m) 좌표에 묻혀있습니다. 또한, 일부 칸에는 함정이 있으며, 해당 칸으로는 지나갈 수 없습니다.
        진수는 처음에 (1, 1) 좌표에서 출발해 보물이 있는 칸으로 이동하려 합니다. 이동할 때는 [상,하,좌,우]로 인접한 네 칸 중 한 칸으로 걸어서 이동합니다. 한 칸을 걸어서 이동하는 데 걸리는 시간은 1입니다.
        진수는 보물이 위치한 칸으로 수월하게 이동하기 위해 신비로운 신발을 하나 준비했습니다. 이 신발을 신고 뛰면 한 번에 두 칸을 이동할 수 있으며, 함정이 있는 칸도 넘을 수 있습니다. 하지만, 이 신발은 한 번밖에 사용할 수 없습니다. 신비로운 신발을 사용하여 뛰어서 두 칸을 이동하는 시간도 1입니다.
        이때 진수가 출발점에서 보물이 위치한 칸으로 이동하는데 필요한 최소 시간을 구해야 합니다.

        예를 들어, 진수의 보물지도가 아래 그림과 같을 때, 진수가 걸어서 오른쪽으로 3칸, 걸어서 위쪽으로 3칸 이동하면 6의 시간에 보물이 위치한 칸으로 이동할 수 있습니다. 만약, 오른쪽으로 걸어서 1칸, 위쪽으로 걸어서 1칸, 신비로운 신발을 사용하여 위로 뛰어 2칸, 오른쪽으로 걸어서 2칸 이동한다면 총 5의 시간에 보물이 위치한 칸으로 이동할 수 있으며, 이보다 빠른 시간 내에 보물이 있는 위치에 도착할 수 없습니다.
            [그림은 문제에서 참고]

        진수의 보물지도가 표현하는 지역의 가로 길이를 나타내는 정수 n, 세로 길이를 나타내는 정수 m, 함정의 위치를 나타내는 2차원 정수 배열 hole이 주어졌을 때, 진수가 보물이 있는 칸으로 이동하는데 필요한 최소 시간을 return 하는 solution 함수를 완성해주세요. 단, 보물이 있는 칸으로 이동할 수 없다면, -1을 return 해야 합니다.


    제한사항
        · 1 ≤ n, m ≤ 1,000
            · 단, n * m이 3 이상인 경우만 입력으로 주어집니다.
        · 1 ≤ hole의 길이 ≤ n * m - 2
            · hole[i]는 [a, b]의 형태이며, (a, b) 칸에 함정이 존재한다는 의미이며, 1 ≤ a ≤ n, 1 ≤ b ≤ m을 만족합니다.
            · 같은 함정에 대한 정보가 중복해서 들어있지 않습니다.
        · (1, 1) 칸과 (n, m) 칸은 항상 함정이 없습니다.


    입출력 예
        n	m	hole	                                                                    result
        4	4	[[2, 3], [3, 3]]	                                                        5
        5	4	[[1, 4], [2, 1], [2, 2], [2, 3], [2, 4], [3, 3], [4, 1], [4, 3], [5, 3]]	-1


    입출력 예 설명
        입출력 예 #1
            · 본문의 예시와 같습니다.

        입출력 예 #2
            · 보물지도를 그림으로 나타내면 아래와 같으며, 보물이 위치한 칸으로 이동할 수 없습니다. 따라서, -1을 return 해야 합니다.
                [그림은 문제에서 참고]
*/


/*
    정확성  테스트
        테스트 1 〉통과 (0.33ms, 70.6MB)
        테스트 2 〉통과 (156.45ms, 133MB)
        테스트 3 〉통과 (20.64ms, 104MB)
        테스트 4 〉통과 (13.17ms, 95.3MB)
        테스트 5 〉통과 (7.84ms, 91.3MB)
        테스트 6 〉통과 (128.23ms, 127MB)
        테스트 7 〉통과 (8.29ms, 88.7MB)
        테스트 8 〉통과 (53.90ms, 102MB)
        테스트 9 〉통과 (72.34ms, 104MB)
        테스트 10 〉통과 (52.85ms, 120MB)
        테스트 11 〉통과 (156.78ms, 131MB)
        테스트 12 〉통과 (116.18ms, 286MB)
        테스트 13 〉통과 (164.39ms, 226MB)
        테스트 14 〉통과 (124.55ms, 265MB)
        테스트 15 〉통과 (257.73ms, 196MB)
        테스트 16 〉통과 (157.73ms, 200MB)
        테스트 17 〉통과 (0.32ms, 76.3MB)
        테스트 18 〉통과 (0.34ms, 79MB)
        테스트 19 〉통과 (0.32ms, 78.5MB)

    채점 결과
        정확성: 100.0
        합계: 100.0 / 100.0
*/


// 정답

import java.util.*;

class Solution {
    int[][][] map; // 보물 지도의 정보 및 각 좌표까지 이동하는 데 걸린 시간을 저장하는 배열 (map[y][x][0] : 신비로운 신발을 사용하지 않고 좌표 (x, y)까지 이동하는 데 걸린 시간, map[y][x][1] : 신비로운 신발을 사용하고 좌표 (x, y)까지 이동하는 데 걸린 시간)
    int[] dx = {0, 0, -1, 1}; // 상, 하, 좌, 우
    int[] dy = {-1, 1, 0, 0}; // 상, 하, 좌, 우
    Queue<Player> queue; // 진수가 이동한 좌표에서의 상태를 저장하는 큐

    class Player { // 진수의 상태(좌표, 이동한 시간, 신비로운 신발 사용 여부)를 저장하는 클래스
        int nowX; // 현재 위치한 x 좌표
        int nowY; // 현재 위치한 y 좌표
        int time; // 이동한 시간
        boolean isUsed; // 신비로운 신발 사용 여부

        public Player(int nowX, int nowY, int time, boolean isUsed) {
            this.nowX = nowX;
            this.nowY = nowY;
            this.time = time;
            this.isUsed = isUsed;
        }
    }

    public boolean check(int n, int m, int x, int y) { // 해당 좌표가 보물 지도의 범위 내에 속하는 좌표인지 검사하는 메서드
        if (x >= 1 && x <= n && y >= 1 && y <= m) {
            return true;
        }

        return false;
    }

    public void go(int n, int m, Player player, int distance, boolean isUsed) { // 이동하는 메서드
        int status = isUsed ? 1 : 0; // 신비로운 신발 사용 상태 인덱스 (신비로운 신발을 사용하지 않은 상태일 경우 0, 신비로운 신발을 사용한 상태일 경우 1)

        for (int d = 0; d < 4; d++) {
            int nx = player.nowX + distance * dx[d]; // 이동할 x 좌표
            int ny = player.nowY + distance * dy[d]; // 이동할 y 좌표

            if (check(n, m, nx, ny) && (map[ny][nx][status] != -1)) { // 이동할 좌표가 보물 지도 범위 내의 좌표이고, 그 좌표에 함정이 없을 경우
                if (map[ny][nx][status] > (player.time + 1)) { // 이동할 좌표가 이전에 그 좌표까지 이동하는 데 걸린 시간보다 현재 이동하는 시간이 더 적게 걸릴 경우
                    map[ny][nx][status] = player.time + 1; // 이동할 좌표까지 걸리는 시간 갱신
                    queue.offer(new Player(nx, ny, map[ny][nx][status], isUsed)); // 해당 좌표와 이동 시 상태를 큐에 추가
                }
            }
        }
    }

    public void find(int n, int m) { // 진수가 보물이 있는 칸으로 이동하는 데 필요한 최소 시간을 구하는 메서드
        queue = new ArrayDeque<>();

        queue.offer(new Player(1, 1, 0, false)); // 진수가 처음 위치한 좌표에서의 상태 큐에 추가
        while (!queue.isEmpty()) {
            Player nowPlayer = queue.poll(); // 진수가 현재 위치한 좌표에서의 상태

            go(n, m, nowPlayer, 1, nowPlayer.isUsed); // 신비로운 신발을 사용하지 않고 이동

            if (!nowPlayer.isUsed) { // 신비로운 신발을 사용하지 않은 상태일 경우
                go(n, m, nowPlayer, 2, true); // 신비로운 신발을 사용하여 이동
            }
        }
    }

    public int solution(int n, int m, int[][] hole) {
        map = new int[m + 1][n + 1][2];

        // 보물 지도의 이동하지 않은 좌표 표시
        for (int r = 1; r <= m; r++) {
            for (int c = 1; c <= n; c++) {
                map[r][c][0] = Integer.MAX_VALUE;
                map[r][c][1] = Integer.MAX_VALUE;
            }
        }

        // 함정 정보 보물 지도에 기록
        for (int h = 0, num = hole.length; h < num; h++) {
            map[hole[h][1]][hole[h][0]][0] = -1;
            map[hole[h][1]][hole[h][0]][1] = -1;
        }

        find(n, m); // 진수가 보물이 있는 칸으로 이동하는 데 필요한 최소 시간을 구한다.

        int minTime = Math.min(map[m][n][0], map[m][n][1]); // 신비로운 신발을 사용하지 않고 좌표 (n, m)까지 이동하는 데 걸린 시간과 신비로운 신발을 사용하여 좌표 (n, m)까지 이동하는 데 걸린 시간 중 최솟값

        return (minTime == Integer.MAX_VALUE) ? -1 : minTime; // 보물이 있는 칸으로 이동할 수 없을 경우 -1 반환, 보물이 있는 칸으로 이동할 수 있을 경우 보물 지도의 좌표 (n, m)에 기록된 해당 좌표까지 이동하는 데 필요한 최소 시간 반환
    }
}