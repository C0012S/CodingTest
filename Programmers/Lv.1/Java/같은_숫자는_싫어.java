/*
Lv. 1 - 같은 숫자는 싫어

    문제 설명
        배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,
            · arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
            · arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.

        배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.


    제한사항
        · 배열 arr의 크기 : 1,000,000 이하의 자연수
        · 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수


    입출력 예
        arr	                answer
        [1,1,3,3,0,1,1]	    [1,3,0,1]
        [4,4,4,3,3]	        [4,3]


    입출력 예 설명
        입출력 예 #1,2
        문제의 예시와 같습니다.
*/


/*
    정확성  테스트
        테스트 1 〉	통과 (0.16ms, 80.8MB)
        테스트 2 〉	통과 (0.24ms, 80.6MB)
        테스트 3 〉	통과 (0.26ms, 74.7MB)
        테스트 4 〉	통과 (0.33ms, 82.2MB)
        테스트 5 〉	통과 (0.29ms, 78.8MB)
        테스트 6 〉	통과 (0.26ms, 77.9MB)
        테스트 7 〉	통과 (0.27ms, 72.5MB)
        테스트 8 〉	통과 (0.20ms, 75.4MB)
        테스트 9 〉	통과 (0.23ms, 73.2MB)
        테스트 10 〉	통과 (0.26ms, 75.3MB)
        테스트 11 〉	통과 (0.22ms, 73.8MB)
        테스트 12 〉	통과 (0.17ms, 72.2MB)
        테스트 13 〉	통과 (0.36ms, 75MB)
        테스트 14 〉	통과 (0.24ms, 75.9MB)
        테스트 15 〉	통과 (0.30ms, 74.2MB)
        테스트 16 〉	통과 (0.26ms, 73.3MB)
        테스트 17 〉	통과 (0.11ms, 71.8MB)

    효율성  테스트
        테스트 1 〉	통과 (49.95ms, 111MB)
        테스트 2 〉	통과 (50.36ms, 111MB)
        테스트 3 〉	통과 (48.94ms, 116MB)
        테스트 4 〉	통과 (53.37ms, 117MB)

    채점 결과
        정확성: 71.9
        효율성: 28.1
        합계: 100.0 / 100.0
*/


// 정답

import java.util.*;

public class Solution {
    public int[] solution(int []arr) {
        Stack<Integer> stack = new Stack<>();
        for (int element : arr) { // 배열의 원소를 모두 검사
            if (stack.isEmpty() || stack.peek() != element) { // 스택이 비었거나, 이전에 온 값이 배열의 해당 원소와 같지 않을 경우
                stack.push(element); // 스택에 배열의 해당 원소를 추가
            }
        }

        int size = stack.size(); // 스택의 크기
        int answer[] = new int[size]; // 배열의 크기를 스택의 크기만큼 설정하여 정답 배열 생성
        for (int a = size - 1; a >= 0; a--) { // 배열의 마지막 인덱스부터 첫 번째 인덱스까지
            answer[a] = stack.pop(); // 스택의 최근 원소를 배열의 해당 인덱스의 원소로 저장
        }

        return answer;
    }
}